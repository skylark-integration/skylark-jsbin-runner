{"version":3,"sources":["processor.js"],"names":["define","loopProtect","runner","regex","processor","blockingMethods","kill","restore","getDoctype","str","doctype","match","tail","substr","length","debug","source","replace","m","render","options","combinedSource","realtime","requested","noRealtimeJs","includeJsInRealtime","doctypeObj","push","join","escapeMap","<",">","&","re","docReady","shortDocReady","console","script","code","csscode","description","title","winLoad","scriptopen","prepare","codes","lastIndex","parts","html","js","javascript","css","close","hasHTML","trim","hasCSS","hasJS","alias","test","all","arg","split","indexOf","substring","lastIndexOf","pos","open"],"mappings":";;;;;;;AAAAA,QACG,sBACA,YACD,SAAUC,EAAaC,GACrB,aAMA,IAkBMC,EAlBFC,KAEJA,EAAUC,iBACRC,KAAM,sNAINC,QAAS,kKAQXH,EAAUI,YAGJL,EAAQ,uBACL,SAAUM,GACf,IAAIC,GAAWD,EAAIE,MAAMR,KAAW,KAAK,GAEzC,OACEO,QAASA,EACTE,KAHSH,EAAII,OAAOH,EAAQI,WAWlCV,EAAUW,MAAQ,SAAUC,GAC1B,MAAO,QAAUA,EAAOC,QAAQ,SAAU,SAAUC,GAClD,MAAS,KAALA,EAAiB,OACZ,KAALA,EAAiB,OACZ,KAALA,EAAiB,aAArB,IACG,UAOPd,EAAUe,OAAS,SAAUH,EAAQI,GAEnCA,EAAUA,MACVJ,EAASA,GAAU,GAEnB,IAAIK,KACAC,GAAkC,IAAtBF,EAAQG,UACpBC,GAAgD,IAAhCJ,EAAQK,oBAIxBH,GAAYE,IACdR,EAASA,EAAOC,QAAQ,sDAAuD,KAKjFD,EAASA,EAAOC,QAAQ,uBAAwB,MAGhD,IAAIS,EAAatB,EAAUI,WAAWQ,GAClCN,EAAUgB,EAAWhB,QAoBzB,OAnBAM,EAASU,EAAWd,KACpBS,EAAeM,KAAKjB,GAKhBY,GAAYF,EAAQK,qBACtBJ,EAAeM,KAAKvB,EAAUC,gBAAgBC,MAIhDe,EAAeM,KAAKX,GAGhBM,GAAYF,EAAQK,qBACtBJ,EAAeM,KAAKvB,EAAUC,gBAAgBE,SAI5Ca,EAAQL,MACHX,EAAUW,MAAMM,EAAeO,KAAK,OAGtCP,EAAeO,KAAK,OAM7B,IAAIC,GACFC,IAAK,OACLC,IAAK,OACLC,IAAK,SACJC,GACCC,SAAU,wBACVC,cAAe,eACfC,QAAS,yBAETC,OAAQ,cACRC,KAAM,SACNC,QAAS,QAETC,YAAa,gDACbC,MAAO,yBACPC,QAAS,qBACTC,WAAY,aAiJhB,OA9IAvC,EAAUwC,QAAU,SAASC,GAE3BZ,EAAGC,SAASY,UAAY,EACxBb,EAAGE,cAAcW,UAAY,EAC7Bb,EAAGG,QAAQU,UAAY,EACvBb,EAAGI,OAAOS,UAAY,EACtBb,EAAGK,KAAKQ,UAAY,EACpBb,EAAGM,QAAQO,UAAY,EACvBb,EAAGQ,MAAMK,UAAY,EACrBb,EAAGS,QAAQI,UAAY,EACvBb,EAAGU,WAAWG,UAAY,EAE1B,IAAIC,KACAC,EAAOH,EAAMG,KACbC,EAAKJ,EAAMK,YAAc,GACzBC,EAAMN,EAAMM,IACZC,EAAQ,GACRC,IAAYL,EAAKM,OAAOxC,OACxByC,IAAWJ,EAAIG,OAAOxC,OACtB0C,IAAUP,EAAGK,OAAOxC,OAmCxB,GA5BIuC,IACFJ,EAAK,QAAUA,EAAK,sCAGtBhD,EAAYwD,MAAQ,8BAQpBR,GAHAA,EAAKhD,EAAYgD,IAGThC,QAAQgB,EAAGI,OAAQ,cAGvBJ,EAAGG,QAAQsB,KAAKT,KAKlBA,EAAKA,EAAGhC,QAAQgB,EAAGG,QAAS,SAAUuB,EAAKlD,EAAKmD,GAC9C,MA3Bc,oCA2BOA,MAOpBP,GAAWG,EACdR,EAAO,UAAYC,EAAGhC,QAAQ,SAAU,SAAUC,GAChD,OAAOW,EAAUX,KACd,cACA,GAAIe,EAAGK,KAAKoB,KAAKV,GACtBA,EAAOA,EAAKa,MAAM,UAAUjC,KAAKU,KAAKY,iBACjC,GAAIM,EAAO,CAChBJ,EAAQ,IACyB,IAA7BJ,EAAKc,QAAQ,aACff,EAAMpB,KAAKqB,EAAKe,UAAU,EAAGf,EAAKgB,YAAY,aAC9CjB,EAAMpB,KAAKqB,EAAKe,UAAUf,EAAKgB,YAAY,aAE3ChB,EAAOD,EAAM,GACbK,EAAyB,IAAjBL,EAAMjC,QAAgBiC,EAAM,GAAKA,EAAM,GAAK,IAQtDC,GAAQ,sBAAyBC,EAAK,iBAAkBG,EAI1D,GAAInB,EAAGG,QAAQsB,KAAKV,GAAO,CAMzBA,EAAOA,EAAK/B,QAAQgB,EAAGG,QAAS,SAAUuB,EAAKlD,EAAKmD,EAAKK,GACvD,IAAIC,EAAOlB,EAAKgB,YAAY,UAAWC,GACnCb,EAAQJ,EAAKgB,YAAY,WAAYC,GAKzC,OAFQ,KAEJC,EAAOd,EAxEG,oCAyESQ,EAEdD,IA4Cb,OAvCKN,GAAYG,IAASD,EAIftB,EAAGM,QAAQmB,KAAKV,GACzBA,EAAOA,EAAKa,MAAM,SAASjC,KAAKuB,GACvBE,IACTN,KACAK,EAAQ,IACyB,IAA7BJ,EAAKc,QAAQ,aACff,EAAMpB,KAAKqB,EAAKe,UAAU,EAAGf,EAAKc,QAAQ,aAC1Cf,EAAMpB,KAAKqB,EAAKe,UAAUf,EAAKc,QAAQ,aAEvCd,EAAOD,EAAM,GACbK,EAAyB,IAAjBL,EAAMjC,QAAgBiC,EAAM,GAAKA,EAAM,GAAK,IAQtDC,GAAQ,2BAA6BG,EAAM,eAAiBC,GArB5DJ,EAAO,UAAYG,EAAIlC,QAAQ,SAAU,SAAUC,GACjD,OAAOW,EAAUX,KACd,SAoCA8B,GAGF9C,EAAOE,UAAYA","file":"../processor.js","sourcesContent":["define([\r\n   \"skylark-loopprotect\",\r\n   \"./runner\"\r\n],function (loopProtect, runner) {\r\n    'use strict';\r\n  /** =========================================================================\r\n   * Processor\r\n   * Modify the prepared source ready to be written to an iframe\r\n   * ========================================================================== */\r\n\r\n    var processor = {};\r\n\r\n    processor.blockingMethods = {\r\n      kill: '<script>(function(){window.__blocked={methods:[\"open\",\"print\",\"alert\",\"prompt\",\"confirm\"],old:{}};for(var m in __blocked.methods){try {__blocked.old[m]=window[m];window[m]=function(){};}catch(e){}}})()</script>',\r\n      // RS: the empty comment in the end of the harness, ensures any\r\n      // open comments are closed, and will ensure the harness is hidden\r\n      // from the user.\r\n      restore: '<!--jsbin live harness--><script>(function(){for(var m in __blocked.methods){try{window[m]=__blocked.old[m];delete __blocked;}catch(e){}};})()</script>'\r\n    };\r\n\r\n    /**\r\n     * Grab the doctype from a string.\r\n     *\r\n     * Returns an object with doctype and tail keys.\r\n     */\r\n    processor.getDoctype = (function () {\r\n      // Cached regex\r\n      // [\\s\\S] matches multiline doctypes\r\n      var regex = /<!doctype [\\s\\S]*?>/i;\r\n      return function (str) {\r\n        var doctype = (str.match(regex) || [''])[0],\r\n            tail = str.substr(doctype.length);\r\n        return {\r\n          doctype: doctype,\r\n          tail: tail\r\n        };\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * Replace HTML characters with encoded equivatents for debug mode.\r\n     */\r\n    processor.debug = function (source) {\r\n      return '<pre>' + source.replace(/[<>&]/g, function (m) {\r\n        if (m == '<') return '&lt;';\r\n        if (m == '>') return '&gt;';\r\n        if (m == '&') return '&amp;';\r\n      }) + '</pre>';\r\n    };\r\n\r\n    /**\r\n     * Render – build the final source code to be written to the iframe. Takes\r\n     * the original source and an options object.\r\n     */\r\n    processor.render = function (source, options) {\r\n\r\n      options = options || {};\r\n      source = source || '';\r\n\r\n      var combinedSource = [],\r\n          realtime = (options.requested !== true),\r\n          noRealtimeJs = (options.includeJsInRealtime === false);\r\n\r\n      // If the render was realtime and we don't want javascript in realtime\r\n      // renders – Auto-run JS is unchecked – then strip out the Javascript\r\n      if (realtime && noRealtimeJs) {\r\n        source = source.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\r\n      }\r\n\r\n      // Strip autofocus from the markup, preventing the focus switching out of\r\n      // the editable area.\r\n      source = source.replace(/(<.*?\\s)(autofocus)/g, '$1');\r\n\r\n      // Make sure the doctype is the first thing in the source\r\n      var doctypeObj = processor.getDoctype(source),\r\n          doctype = doctypeObj.doctype;\r\n      source = doctypeObj.tail;\r\n      combinedSource.push(doctype);\r\n\r\n      // Kill the blocking functions\r\n      // IE requires that this is done in the script, rather than off the window\r\n      // object outside of the doc.write.\r\n      if (realtime && options.includeJsInRealtime) {\r\n        combinedSource.push(processor.blockingMethods.kill);\r\n      }\r\n\r\n      // Push the source, split from the doctype above.\r\n      combinedSource.push(source);\r\n\r\n      // Restore the blocking functions\r\n      if (realtime && options.includeJsInRealtime) {\r\n        combinedSource.push(processor.blockingMethods.restore);\r\n      }\r\n\r\n      // In debug mode return an escaped version\r\n      if (options.debug) {\r\n        return processor.debug(combinedSource.join('\\n'));\r\n      }\r\n\r\n      return combinedSource.join('\\n');\r\n\r\n    };\r\n\r\n\r\n    //moved from render/live.js(getPreparedCode)\r\n    var escapeMap = {\r\n      '<': '&lt;',\r\n      '>': '&gt;',\r\n      '&': '&amp;'\r\n    }, re = {\r\n        docReady: /\\$\\(document\\)\\.ready/,\r\n        shortDocReady: /\\$\\(function/,\r\n        console: /(^.|\\b)console\\.(\\S+)/g,\r\n\r\n        script: /<\\/script/ig,\r\n        code: /%code%/,\r\n        csscode: /%css%/,\r\n\r\n        description: /(<meta name=\"description\" content=\")([^\"]*)/im,\r\n        title: /<title>(.*)<\\/title>/im,\r\n        winLoad: /window\\.onload\\s*=/,\r\n        scriptopen: /<script/gi\r\n    };\r\n\r\n    processor.prepare = function(codes) {\r\n      // reset all the regexp positions for reuse\r\n      re.docReady.lastIndex = 0;\r\n      re.shortDocReady.lastIndex = 0;\r\n      re.console.lastIndex = 0;\r\n      re.script.lastIndex = 0;\r\n      re.code.lastIndex = 0;\r\n      re.csscode.lastIndex = 0;\r\n      re.title.lastIndex = 0;\r\n      re.winLoad.lastIndex = 0;\r\n      re.scriptopen.lastIndex = 0;\r\n\r\n      var parts = [],\r\n          html = codes.html,\r\n          js = codes.javascript || '',\r\n          css = codes.css,\r\n          close = '',\r\n          hasHTML = !!html.trim().length,\r\n          hasCSS = !!css.trim().length,\r\n          hasJS = !!js.trim().length,\r\n          replaceWith = 'window.runnerWindow.proxyConsole.';\r\n\r\n      // this is used to capture errors with processors, sometimes their errors\r\n      // aren't useful (Script error. (line 0) #1354) so we try/catch and then\r\n      // throw the real error. This also works exactly as expected with non-\r\n      // processed JavaScript\r\n      if (hasHTML) {\r\n        js = 'try {' + js + '\\n} catch (error) { throw error; }';\r\n      }\r\n\r\n      loopProtect.alias = 'window.runnerWindow.protect';\r\n\r\n      // Rewrite loops to detect infiniteness.\r\n      // This is done by rewriting the for/while/do loops to perform a check at\r\n      // the start of each iteration.\r\n      js = loopProtect(js);\r\n\r\n      // escape any script tags in the JS code, because that'll break the mushing together\r\n      js = js.replace(re.script, '<\\\\/script');\r\n\r\n      // redirect console logged to our custom log while debugging\r\n      if (re.console.test(js)) {\r\n        // yes, this code looks stupid, but in fact what it does is look for\r\n        // 'console.' and then checks the position of the code. If it's inside\r\n        // an openning script tag, it'll change it to window.top._console,\r\n        // otherwise it'll leave it.\r\n        js = js.replace(re.console, function (all, str, arg) {\r\n          return replaceWith + arg;\r\n        });\r\n      }\r\n\r\n      // note that I'm using split and reconcat instead of replace, because if\r\n      // the js var contains '$$' it's replaced to '$' - thus breaking Prototype\r\n      // code. This method gets around the problem.\r\n      if (!hasHTML && hasJS) {\r\n        html = '<pre>\\n' + js.replace(/[<>&]/g, function (m) {\r\n          return escapeMap[m];\r\n        }) + '</pre>';\r\n      } else if (re.code.test(html)) {\r\n        html = html.split('%code%').join(code.javascript);\r\n      } else if (hasJS) {\r\n        close = '';\r\n        if (html.indexOf('</body>') !== -1) {\r\n          parts.push(html.substring(0, html.lastIndexOf('</body>')));\r\n          parts.push(html.substring(html.lastIndexOf('</body>')));\r\n\r\n          html = parts[0];\r\n          close = parts.length === 2 && parts[1] ? parts[1] : '';\r\n        }\r\n\r\n        // TODO\r\n        ///var type = jsbin.panels.named.javascript.type ? ' type=\"text/' + jsbin.panels.named.javascript.type + '\"' : '';\r\n        /// js += '\\n\\n//# sourceURL=' + jsbin.state.code + '.js';\r\n        var type = \"text/script\";\r\n\r\n        html += '<script' + type + '>' + js + '\\n</script>\\n' + close;\r\n      }\r\n\r\n      // reapply the same proxyConsole - but to all the html code, since\r\n      if (re.console.test(html)) {\r\n        // yes, this code looks stupid, but in fact what it does is look for\r\n        // 'console.' and then checks the position of the code. If it's inside\r\n        // an openning script tag, it'll change it to window.top._console,\r\n        // otherwise it'll leave it.\r\n        var first = ' /* double call explained https://github.com/jsbin/jsbin/issues/1833 */';\r\n        html = html.replace(re.console, function (all, str, arg, pos) {\r\n          var open = html.lastIndexOf('<script', pos),\r\n              close = html.lastIndexOf('</script', pos),\r\n              info = first;\r\n\r\n          first = null;\r\n\r\n          if (open > close) {\r\n            return replaceWith + arg;\r\n          } else {\r\n            return all;\r\n          }\r\n        });\r\n      }\r\n\r\n      if (!hasHTML && !hasJS && hasCSS) {\r\n        html = '<pre>\\n' + css.replace(/[<>&]/g, function (m) {\r\n          return escapeMap[m];\r\n        }) + '</pre>';\r\n      } else if (re.csscode.test(html)) {\r\n        html = html.split('%css%').join(css);\r\n      } else if (hasHTML) {\r\n        parts = [];\r\n        close = '';\r\n        if (html.indexOf('</head>') !== -1) {\r\n          parts.push(html.substring(0, html.indexOf('</head>')));\r\n          parts.push(html.substring(html.indexOf('</head>')));\r\n\r\n          html = parts[0];\r\n          close = parts.length === 2 && parts[1] ? parts[1] : '';\r\n        }\r\n\r\n        // if the focused panel is CSS, then just return the css NOW\r\n        ///if (jsbin.state.hasBody && jsbin.panels.focused.id === 'css') {\r\n        ///  return css;\r\n        ///}\r\n\r\n        html += '<style id=\"jsbin-css\">\\n' + css + '\\n</style>\\n' + close;\r\n      }\r\n\r\n      // Add defer to all inline script tags in IE.\r\n      // This is because IE runs scripts as it loads them, so variables that\r\n      // scripts like jQuery add to the global scope are undefined.\r\n      // See http://jsbin.com/ijapom/5\r\n      ///if (jsbin.ie && re.scriptopen.test(html)) {\r\n      ///  html = html.replace(/<script(.*?)>/gi, function (all, match) {\r\n      ///    if (match.indexOf('src') !== -1) {\r\n      ///      return all;\r\n      ///    } else {\r\n      ///      return '<script defer' + match + '>';\r\n      ///    }\r\n      ///  });\r\n      ///}\r\n\r\n      return html;\r\n    };\r\n\r\n    return runner.processor = processor;\r\n\r\n});\r\n"]}